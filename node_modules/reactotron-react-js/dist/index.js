'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var StackTrace = _interopDefault(require('stacktrace-js'));
var reactotronCoreClient = require('reactotron-core-client');

/**
 * Provides a global error handler to report errors with sourcemap lookup.
 */

// what to say whe we can't resolve source maps
var CANNOT_RESOLVE_ERROR = 'Unable to resolve error.  Either support CORS by changing webpack\'s devtool to "source-map" or run in offline mode.';

// defaults
var PLUGIN_DEFAULTS = {
  offline: false };

// our plugin entry point
var trackGlobalErrors = (function (options) {
  return function (reactotron) {
    // setup configuration
    var config = Object.assign({}, PLUGIN_DEFAULTS, options || {});

    // holds the previous window.onerror when needed
    var swizzledOnError = null;
    var isSwizzled = false;

    // the functionality of our window.onerror.
    // we could have used window.addEventListener("error", ...) but that doesn't work on all browsers
    function windowOnError(msg, file, line, col, error) {
      // resolve the stack trace
      StackTrace.fromError(error, { offline: config.offline })
      // then try to send it up to the server
      .then(function (stackFrames) {
        return reactotron.error(msg, stackFrames);
      })
      // can't resolve, well, let the user know, but still upload something sane
      .catch(function (resolvingError) {
        return reactotron.error({
          message: CANNOT_RESOLVE_ERROR,
          original: { msg: msg, file: file, line: line, col: col, error: error },
          resolvingError: resolvingError
        });
      });

      // call back the previous window.onerror if we have one
      if (swizzledOnError) {
        swizzledOnError(msg, file, line, col, error);
      }
    }

    // swizzles window.onerror dropping in our new one
    function trackGlobalErrors() {
      if (isSwizzled) return;
      swizzledOnError = window.onerror;
      window.onerror = windowOnError;
      isSwizzled = true;
    }

    // restore the original
    function untrackGlobalErrors() {
      if (!swizzledOnError) return;
      window.onerror = swizzledOnError;
      isSwizzled = false;
    }

    // auto start this
    trackGlobalErrors();

    // the reactotron plugin interface
    return {
      // attach these functions to the Reactotron
      features: {
        trackGlobalErrors: trackGlobalErrors,
        untrackGlobalErrors: untrackGlobalErrors
      }
    };
  };
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

// ---------------------
// DEFAULT CONFIGURATION
// ---------------------

var REACTOTRON_ASYNC_CLIENT_ID = '@REACTOTRON/clientId';

/**
 * Safely get some information out the the window.navigator.
 *
 * @param {string} name The property to get.
 */
function getNavigatorProperty(name) {
  if (!name) return undefined;
  if (!window) return undefined;
  if (!window.navigator && _typeof(window.navigator) !== "object") return undefined;
  return window.navigator[name];
}

var DEFAULTS = {
  createSocket: function createSocket(path) {
    return new WebSocket(path);
  }, // eslint-disable-line
  host: "localhost",
  port: 9090,
  name: "React JS App",
  client: {
    reactotronLibraryName: "reactotron-react-js",
    reactotronLibraryVersion: '2.1.1',
    platform: "browser",
    platformVersion: getNavigatorProperty("platform"),
    userAgent: getNavigatorProperty("userAgent"),
    screenWidth: screen && screen.width || undefined,
    screenHeight: screen && screen.height || undefined,
    screenScale: window && window.devicePixelRatio || 1,
    windowWidth: window && window.innerWidth || undefined,
    windowHeight: window && window.innerHeight || undefined
  },
  getClientId: function getClientId() {
    return Promise.resolve(localStorage.getItem(REACTOTRON_ASYNC_CLIENT_ID));
  },
  setClientId: function setClientId(clientId) {
    localStorage.setItem(REACTOTRON_ASYNC_CLIENT_ID, clientId);
  }
};

// -----------
// HERE WE GO!
// -----------
// Create the default reactotron.
var index = reactotronCoreClient.createClient(DEFAULTS);

exports.trackGlobalErrors = trackGlobalErrors;
exports.default = index;
